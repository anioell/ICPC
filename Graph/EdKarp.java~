/* EdmondsKarp
 ** |V|^2 \cdot |E|
 * Finds the greatest flow in a graph. Capacities must be positive.
 */

//START
public static boolean BFS(Vertex[] G, int s, int t) {
   int N = G.length;
   for(int i = 0; i < N; i++) {
      G[i].vis = false;
   }
   
   Queue<Vertex> q = new LinkedList<Vertex>();
   G[s].vis = true;
   G[s].pre = -1;
   queue.add(G[s]);
   
   while(!q.isEmpty()) {
      Vertex u = queue.poll();
      if(u.id == t) return true;
      for(Edge e : u.adj) {
	  Vertex v = e.t;
	  if(!v.vis) {
	      v.vis = true;
	      v.pre = u.id;
	      q.add(v);
	  }
      }
   }
   return (G[t].vis);
}
//END

//START
public static int fordFulkerson(Vertex[] G, int s, int t) {
   int N = G.length;
   int[][] rgraph = new int[graph.length][graph.length];
   for(int u = 0; u < graph.length; u++) {
      for(int v = 0; v < graph.length; v++) {
         rgraph[u][v] = graph[u][v];
      }
   }
   int[] parent = new int[N];
   int maxflow = 0;
   while(BFS(rgraph, s, t, parent)) {
      int pathflow = Integer.MAX_VALUE;
      for(int v = t; v!= s; v = parent[v]) {
         int u = parent[v];
         pathflow = Math.min(pathflow, rgraph[u][v]);
      }

      for(int v = t; v != s; v = parent[v]) {
         int u = parent[v];
         rgraph[u][v] -= pathflow;
         rgraph[v][u] += pathflow;
      }

      maxflow += pathflow;
   }
   return maxflow;
}
//END
